# Look/Move Payload Assembly Flow

This document explains how WR2 assembles the data shown in console outputs like `look` and movement, and how that data reaches/render in the frontend.

## Scope

- Primary commands covered:
  - `look` (`cmd.look.success`)
  - movement (`cmd.move.success`)
- Related baseline:
  - initial state snapshot (`cmd.state.sync.success`) uses the same room/map/actor builders.

## Core Data Contract

WR2 uses Pydantic schemas in `backend/spawns/schemas.py` for runtime payload structure, including:

- `StateSyncData`
- `Room`
- `MapRoom`
- `Actor`
- `Item`
- `Char`

The same serialization helpers are reused across state sync, look, and movement to keep payload shape consistent.

## Shared Payload Builders

The main assembly helpers live in `backend/spawns/state_payloads.py`.

Key responsibilities:

1. `collect_map_room_ids(...)`
   - Determines which rooms should be present in `data.map` (current room, visited rooms, landmarks, etc).
2. `door_state_lookup(...)`
   - Computes effective door states (`open` / `closed` / `locked`) per room direction.
3. `build_map_payload(...)`
   - Serializes map rooms and exits into `MapRoom` entries.
4. `serialize_room(...)`
   - Builds full current-room payload, including:
     - `inventory`
     - `chars`
     - exits + door states
     - details/flags/zone metadata
5. `serialize_actor(...)`
   - Builds the current player payload, including inventory/equipment and current room reference key.
6. `build_state_sync(...)`
   - Aggregates map + actor + room + world + who_list for initial/full sync.

## Look Command Assembly

### Backend flow

1. Text `look` is routed via `backend/spawns/handlers/text.py` and resolves to `LookHandler` (`backend/spawns/handlers/information.py`).
2. `LookHandler` calls `LookAction.execute(...)` (`backend/spawns/actions/information.py`).
3. `LookAction`:
   - reloads player with related data (`get_player_with_related`)
   - resolves room/world context
   - builds:
     - `map` via `collect_map_room_ids` + `door_state_lookup` + `build_map_payload`
     - `target` via `serialize_room`
     - `actor` via `serialize_actor`
   - returns one `GameEvent`:
     - `type: cmd.look.success`
     - `data: { actor, target, target_type: "room", map }`
4. Console text for the event is generated by `render_event_text("cmd.look.success", ...)` in `backend/spawns/text_output.py`.

### Resulting payload shape (room look)

```json
{
  "type": "cmd.look.success",
  "data": {
    "actor": { "...": "..." },
    "target": { "...room payload..." },
    "target_type": "room",
    "map": [{ "...map room..." }]
  },
  "text": "<pre-rendered room text>"
}
```

## Movement Command Assembly

### Backend flow

1. Text movement commands (`n`, `north`, etc.) resolve to `MoveHandler` (`backend/spawns/handlers/movement.py`).
2. `MoveHandler` executes transactional state mutation:
   - `ResolveMoveAction` validates direction/exits/doors/stamina
   - `ChangeRoomAction` sets new room
   - `AdjustStaminaAction` consumes stamina
   - persists player and updates viewed rooms
3. After mutation, `BuildMoveEventsAction` (`backend/spawns/actions/movement.py`) assembles output payloads:
   - fresh `room` payload for destination room
   - fresh `map` payload
   - actor payload
   - `door_states` delta entries for frontend map updates
4. Returned events include:
   - actor event `cmd.move.success`
   - optional room notifications:
     - `notification.movement.exit`
     - `notification.movement.enter`

### Resulting payload shape (actor move)

```json
{
  "type": "cmd.move.success",
  "data": {
    "direction": "north",
    "room": { "...destination room payload..." },
    "actor": { "..." },
    "map": [{ "..." }],
    "door_states": [{ "key": "room.X", "direction": "north", "door_state": "closed" }]
  },
  "text": "<pre-rendered move room text>"
}
```

## Text Rendering Layer

Human-readable console text is generated server-side in `backend/spawns/text_output.py`.

- `cmd.look.success` text uses the `target` room payload.
- `cmd.move.success` text uses the `room` payload.
- Room item lines come from each item's `ground_description` when present, else a fallback line is generated.

This keeps textual output deterministic and aligned with structured payload data.

## Publish and Transport to Frontend

1. Handlers call `publish_events(...)` in `backend/spawns/events.py`.
2. Each `GameEvent` is published through `fastapi_app/game_ws.py:publish_to_player` via Redis pub/sub.
3. FastAPI game websocket manager relays messages to the active client connection.

## Frontend Consumption and Rendering

### Store updates

`frontend/src/store/modules/game.ts` `receiveMessage(...)` processes incoming messages.

- `cmd.move.success` updates:
  - `state.room`
  - `state.map`
  - `room_key`
  - target/focus related state
- `cmd.look.success` with `target_type === "room"` updates:
  - `state.room` from `data.target`
  - map and room key

### Console component selection

`frontend/src/components/game/console/Console.vue` maps message types to renderers:

- `cmd.look.success` (room) -> `LookRoom.vue`
- `cmd.move.success` -> `LookRoom.vue`
- `cmd.state.sync.success` -> `LookRoom.vue`

`LookRoom.vue` then renders room name/description/exits/chars/inventory from the message payload and current game state.

## Why This Design Matters

This split keeps WR2 maintainable during transition:

1. Actions own domain logic and return explicit events.
2. Shared serializers ensure consistent payload shape across commands.
3. `render_event_text` centralizes server-side text output rules.
4. Frontend can render rich UI from structured `data` while still showing pre-rendered text.

## Primary Files

- `backend/spawns/handlers/information.py`
- `backend/spawns/handlers/movement.py`
- `backend/spawns/actions/information.py`
- `backend/spawns/actions/movement.py`
- `backend/spawns/state_payloads.py`
- `backend/spawns/text_output.py`
- `backend/spawns/events.py`
- `fastapi_app/game_ws.py`
- `frontend/src/store/modules/game.ts`
- `frontend/src/components/game/console/Console.vue`
- `frontend/src/components/game/console/LookRoom.vue`
